#pragma version 9

// This TEAL was generated by TEALScript v0.69.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_UpdateApplication NOT_IMPLEMENTED create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

abi_route_createApplication:
	// fee: uint64
	txna ApplicationArgs 2
	btoi

	// owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute createApplication(uint64,address)void
	callsub createApplication
	int 1
	return

// createApplication(uint64,address)void
createApplication:
	proto 2 0

	// src/contracts/LimitOrders.algo.ts:21
	// this.orderCounter.value = 0
	byte 0x6f726465725f636f756e746572 // "order_counter"
	int 0
	app_global_put

	// src/contracts/LimitOrders.algo.ts:22
	// this.owner.value = owner
	byte 0x6f776e6572 // "owner"
	frame_dig -1 // owner: Address
	app_global_put

	// src/contracts/LimitOrders.algo.ts:23
	// this.fee.value = fee
	byte 0x666565 // "fee"
	frame_dig -2 // fee: uint64
	app_global_put

	// src/contracts/LimitOrders.algo.ts:24
	// this.feeAccumulated.value = 0
	byte 0x6665655f616363 // "fee_acc"
	int 0
	app_global_put
	retsub

abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	int 1
	return

// updateApplication()void
updateApplication:
	proto 0 0

	// src/contracts/LimitOrders.algo.ts:28
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert
	retsub

abi_route_setFee:
	// ownerFee: uint64
	txna ApplicationArgs 1
	btoi

	// execute setFee(uint64)void
	callsub setFee
	int 1
	return

// setFee(uint64)void
setFee:
	proto 1 0

	// src/contracts/LimitOrders.algo.ts:32
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert

	// src/contracts/LimitOrders.algo.ts:33
	// this.fee.value = ownerFee
	byte 0x666565 // "fee"
	frame_dig -1 // ownerFee: uint64
	app_global_put
	retsub

abi_route_setOwner:
	// newOwner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute setOwner(address)void
	callsub setOwner
	int 1
	return

// setOwner(address)void
setOwner:
	proto 1 0

	// src/contracts/LimitOrders.algo.ts:37
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert

	// src/contracts/LimitOrders.algo.ts:38
	// this.owner.value = newOwner
	byte 0x6f776e6572 // "owner"
	frame_dig -1 // newOwner: Address
	app_global_put
	retsub

abi_route_collectFee:
	// algoAmount: uint64
	txna ApplicationArgs 1
	btoi

	// execute collectFee(uint64)void
	callsub collectFee
	int 1
	return

// collectFee(uint64)void
collectFee:
	proto 1 0

	// src/contracts/LimitOrders.algo.ts:42
	// assert(this.owner.value === this.txn.sender)
	byte 0x6f776e6572 // "owner"
	app_global_get
	txn Sender
	==
	assert

	// src/contracts/LimitOrders.algo.ts:43
	// this.transferTo(this.txn.sender, algoAmount)
	frame_dig -1 // algoAmount: uint64
	txn Sender
	callsub transferTo
	retsub

// transferTo(uint64,address)bool
//
// *********************************************
transferTo:
	proto 2 1

	// src/contracts/LimitOrders.algo.ts:49
	// sendPayment({
	//             sender: this.app.address,
	//             receiver: to,
	//             amount: amount,
	//             fee: 1000
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/contracts/LimitOrders.algo.ts:50
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:51
	// receiver: to
	frame_dig -1 // to: Address
	itxn_field Receiver

	// src/contracts/LimitOrders.algo.ts:52
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// src/contracts/LimitOrders.algo.ts:53
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/contracts/LimitOrders.algo.ts:55
	// return true;
	int 1
	retsub

// arc200TransferTo(uint256,address,application)bool
arc200TransferTo:
	proto 3 1

	// src/contracts/LimitOrders.algo.ts:59
	// return sendMethodCall<[Address, uint256], boolean>({
	//             sender: this.app.address,
	//             name: 'arc200_transfer',
	//             applicationID: arc200Id,
	//             methodArgs: [to, <uint256>amount],
	//             fee: 1000
	//         });
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc200_transfer(address,uint256)bool"
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:60
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:62
	// applicationID: arc200Id
	frame_dig -1 // arc200Id: Application
	itxn_field ApplicationID

	// src/contracts/LimitOrders.algo.ts:63
	// methodArgs: [to, <uint256>amount]
	frame_dig -2 // to: Address
	itxn_field ApplicationArgs
	frame_dig -3 // amount: uint256
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:64
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

// arc200TranferFrom(uint256,address,address,application)bool
arc200TranferFrom:
	proto 4 1

	// src/contracts/LimitOrders.algo.ts:69
	// return sendMethodCall<[Address, Address, uint256], boolean>({
	//             sender: this.app.address,
	//             name: 'arc200_transferFrom',
	//             applicationID: arc200Id,
	//             methodArgs: [from, to, amount],
	//             fee: 1000
	//         });
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc200_transferFrom(address,address,uint256)bool"
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:70
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:72
	// applicationID: arc200Id
	frame_dig -1 // arc200Id: Application
	itxn_field ApplicationID

	// src/contracts/LimitOrders.algo.ts:73
	// methodArgs: [from, to, amount]
	frame_dig -2 // from: Address
	itxn_field ApplicationArgs
	frame_dig -3 // to: Address
	itxn_field ApplicationArgs
	frame_dig -4 // amount: uint256
	itxn_field ApplicationArgs

	// src/contracts/LimitOrders.algo.ts:74
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

abi_route_createAlgoSellOrder:
	// arc200Amount: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// arc200Id: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// algoPayTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute createAlgoSellOrder(uint256,application,pay)void
	callsub createAlgoSellOrder
	int 1
	return

// createAlgoSellOrder(uint256,application,pay)void
createAlgoSellOrder:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/contracts/LimitOrders.algo.ts:105
	// verifyPayTxn(algoPayTxn, {
	//             amount: { greaterThan: 0 },
	//             sender: this.txn.sender,
	//             receiver: this.app.address,
	//             rekeyTo: globals.zeroAddress,
	//             closeRemainderTo: globals.zeroAddress,
	//         })
	// verify amount
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Amount
	int 0
	>
	assert

	// verify sender
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify receiver
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify rekeyTo
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns RekeyTo
	global ZeroAddress
	==
	assert

	// verify closeRemainderTo
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns CloseRemainderTo
	global ZeroAddress
	==
	assert

	// src/contracts/LimitOrders.algo.ts:113
	// orderId = this.orderCounter.value
	byte 0x6f726465725f636f756e746572 // "order_counter"
	app_global_get
	frame_bury 0 // orderId: uint64

	// src/contracts/LimitOrders.algo.ts:114
	// assert(!this.orderbook(orderId).exists)
	frame_dig 0 // orderId: uint64
	itob
	box_len
	swap
	pop
	!
	assert

	// src/contracts/LimitOrders.algo.ts:116
	// this.orderbook(orderId).value = {
	//             maker: this.txn.sender,
	//             arc200Id: arc200Id,
	//             algoAmount: algoPayTxn.amount,
	//             arc200Amount: arc200Amount,
	//             isBuyingAlgo: 0,
	//         }
	frame_dig 0 // orderId: uint64
	itob
	txn Sender
	frame_dig -2 // arc200Id: Application
	itob
	concat
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Amount
	itob
	concat
	frame_dig -3 // arc200Amount: uint256
	concat
	byte 0x00
	concat
	box_put

	// src/contracts/LimitOrders.algo.ts:124
	// this.PlaceOrder.log({
	//             orderId: orderId,
	//             maker: this.txn.sender,
	//             algoAmount: algoPayTxn.amount,
	//             arc200Amount: arc200Amount,
	//             orderDirection: 0
	//         })
	byte 0xe0ce885e // PlaceOrder(uint64,address,uint64,uint256,uint8)
	frame_dig 0 // orderId: uint64
	itob
	txn Sender
	concat
	frame_dig -1 // algoPayTxn: PayTxn
	gtxns Amount
	itob
	concat
	frame_dig -3 // arc200Amount: uint256
	concat
	byte 0x00
	concat
	concat
	log

	// src/contracts/LimitOrders.algo.ts:132
	// this.orderCounter.value = orderId + 1
	byte 0x6f726465725f636f756e746572 // "order_counter"
	frame_dig 0 // orderId: uint64
	int 1
	+
	app_global_put
	retsub

abi_route_createAlgoBuyOrder:
	// algoAmount: uint64
	txna ApplicationArgs 3
	btoi

	// arc200Amount: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// arc200AppId: application
	txna ApplicationArgs 1
	btoi
	txnas Applications

	// execute createAlgoBuyOrder(uint64,uint256,application)void
	callsub createAlgoBuyOrder
	int 1
	return

// createAlgoBuyOrder(uint64,uint256,application)void
createAlgoBuyOrder:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/contracts/LimitOrders.algo.ts:137
	// orderId = this.orderCounter.value
	byte 0x6f726465725f636f756e746572 // "order_counter"
	app_global_get
	frame_bury 0 // orderId: uint64

	// src/contracts/LimitOrders.algo.ts:138
	// assert(!this.orderbook(orderId).exists)
	frame_dig 0 // orderId: uint64
	itob
	box_len
	swap
	pop
	!
	assert

	// src/contracts/LimitOrders.algo.ts:140
	// this.arc200TranferFrom(
	//             arc200AppId,
	//             this.txn.sender,
	//             this.app.address,
	//             arc200Amount
	//         )
	frame_dig -2 // arc200Amount: uint256
	global CurrentApplicationAddress
	txn Sender
	frame_dig -1 // arc200AppId: Application
	callsub arc200TranferFrom

	// src/contracts/LimitOrders.algo.ts:147
	// this.orderbook(orderId).value = {
	//             maker: this.txn.sender,
	//             arc200Id: arc200AppId,
	//             algoAmount: algoAmount,
	//             arc200Amount: arc200Amount,
	//             isBuyingAlgo: 1,
	//         }
	frame_dig 0 // orderId: uint64
	itob
	txn Sender
	frame_dig -1 // arc200AppId: Application
	itob
	concat
	frame_dig -3 // algoAmount: uint64
	itob
	concat
	frame_dig -2 // arc200Amount: uint256
	concat
	byte 0x01
	concat
	box_put

	// src/contracts/LimitOrders.algo.ts:155
	// this.PlaceOrder.log({
	//             orderId: this.orderCounter.value,
	//             maker: this.txn.sender,
	//             algoAmount: algoAmount,
	//             arc200Amount: arc200Amount,
	//             orderDirection: 1
	//         })
	byte 0xe0ce885e // PlaceOrder(uint64,address,uint64,uint256,uint8)
	byte 0x6f726465725f636f756e746572 // "order_counter"
	app_global_get
	itob
	txn Sender
	concat
	frame_dig -3 // algoAmount: uint64
	itob
	concat
	frame_dig -2 // arc200Amount: uint256
	concat
	byte 0x01
	concat
	concat
	log

	// src/contracts/LimitOrders.algo.ts:163
	// this.orderCounter.value = orderId + 1
	byte 0x6f726465725f636f756e746572 // "order_counter"
	frame_dig 0 // orderId: uint64
	int 1
	+
	app_global_put
	retsub

abi_route_fillAlgoToArc200Order:
	// arc200Amount: uint256
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute fillAlgoToArc200Order(uint256,uint64)void
	callsub fillAlgoToArc200Order
	int 1
	return

// fillAlgoToArc200Order(uint256,uint64)void
fillAlgoToArc200Order:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 8

	// src/contracts/LimitOrders.algo.ts:168
	// assert(arc200Amount > 0)
	frame_dig -2 // arc200Amount: uint256
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	b>
	assert

	// src/contracts/LimitOrders.algo.ts:169
	// assert(this.orderbook(orderId).exists)
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop
	assert

	// src/contracts/LimitOrders.algo.ts:170
	// boxSnap = this.orderbook(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//boxSnap

	// src/contracts/LimitOrders.algo.ts:172
	// assert(boxSnap.isBuyingAlgo === 0)
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	byte 0x00
	b==
	assert

	// src/contracts/LimitOrders.algo.ts:174
	// this.arc200TranferFrom(
	//             boxSnap.arc200Id,
	//             this.txn.sender,
	//             boxSnap.maker,
	//             arc200Amount
	//         )
	frame_dig -2 // arc200Amount: uint256
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	txn Sender
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 32 8
	btoi
	callsub arc200TranferFrom

	// src/contracts/LimitOrders.algo.ts:181
	// _amountOfAlgos = (
	//             (arc200Amount * (<uint256>boxSnap.algoAmount)) / boxSnap.arc200Amount
	//         )
	frame_dig -2 // arc200Amount: uint256
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 40 8
	btoi
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	b*
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 48 32
	b/
	frame_bury 1 // _amountOfAlgos: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:185
	// amountOfAlgos = <uint<64>>_amountOfAlgos
	frame_dig 1 // _amountOfAlgos: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 2 // amountOfAlgos: uint64

	// src/contracts/LimitOrders.algo.ts:188
	// newArc200Amount = boxSnap.arc200Amount - arc200Amount
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 48 32
	frame_dig -2 // arc200Amount: uint256
	b-
	frame_bury 3 // newArc200Amount: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:191
	// newAlgoAmount = boxSnap.algoAmount - amountOfAlgos
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 40 8
	btoi
	frame_dig 2 // amountOfAlgos: uint64
	-
	frame_bury 4 // newAlgoAmount: uint64

	// src/contracts/LimitOrders.algo.ts:193
	// denominator = <uint256>amountOfAlgos * <uint256>this.fee.value
	frame_dig 2 // amountOfAlgos: uint64
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	byte 0x666565 // "fee"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	b*
	frame_bury 5 // denominator: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:194
	// feeUint256 = (denominator / <uint256>SCALE)
	frame_dig 5 // denominator: unsafe uint256
	byte 0x00005af3107a4000
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	b/
	frame_bury 6 // feeUint256: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:196
	// fee = <uint64>feeUint256
	frame_dig 6 // feeUint256: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 7 // fee: uint64

	// src/contracts/LimitOrders.algo.ts:198
	// this.transferTo(this.txn.sender, amountOfAlgos - fee)
	frame_dig 2 // amountOfAlgos: uint64
	frame_dig 7 // fee: uint64
	-
	txn Sender
	callsub transferTo

	// src/contracts/LimitOrders.algo.ts:199
	// this.feeAccumulated.value = this.feeAccumulated.value + fee
	byte 0x6665655f616363 // "fee_acc"
	dup
	app_global_get
	frame_dig 7 // fee: uint64
	+
	app_global_put

	// src/contracts/LimitOrders.algo.ts:201
	// this.FillOrder.log({
	//             orderId: orderId,
	//             maker: this.orderbook(orderId).value.maker,
	//             taker: this.txn.sender,
	//             filledAlgoAmount: amountOfAlgos,
	//             filledArc200Amount: arc200Amount,
	//             orderDirection: 0,
	//             fee: <uint256>fee
	//         })
	byte 0x0db8f73c // FillOrder(uint64,address,address,uint64,uint256,uint8,uint256)
	frame_dig -1 // orderId: uint64
	itob
	frame_dig -1 // orderId: uint64
	itob
	box_get
	assert
	extract 0 32
	concat
	txn Sender
	concat
	frame_dig 2 // amountOfAlgos: uint64
	itob
	concat
	frame_dig -2 // arc200Amount: uint256
	concat
	byte 0x00
	concat
	frame_dig 7 // fee: uint64
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	concat
	concat
	log

	// if0_condition
	// src/contracts/LimitOrders.algo.ts:211
	// newAlgoAmount <= 1000
	frame_dig 4 // newAlgoAmount: uint64
	int 1000
	<=
	bz if0_else

	// if0_consequent
	// src/contracts/LimitOrders.algo.ts:212
	// this.orderbook(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del
	b if0_end

if0_else:
	// src/contracts/LimitOrders.algo.ts:214
	// this.orderbook(orderId).value = {
	//                 maker: boxSnap.maker,
	//                 arc200Id: boxSnap.arc200Id,
	//                 algoAmount: newAlgoAmount,
	//                 arc200Amount: newArc200Amount,
	//                 isBuyingAlgo: boxSnap.isBuyingAlgo,
	//             }
	frame_dig -1 // orderId: uint64
	itob
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 32 8
	btoi
	itob
	concat
	frame_dig 4 // newAlgoAmount: uint64
	itob
	concat
	frame_dig 3 // newArc200Amount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	concat
	box_put

if0_end:
	retsub

abi_route_fillArc200ToAlgoOrder:
	// algoPayTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute fillArc200ToAlgoOrder(pay,uint64)void
	callsub fillArc200ToAlgoOrder
	int 1
	return

// fillArc200ToAlgoOrder(pay,uint64)void
fillArc200ToAlgoOrder:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 10

	// src/contracts/LimitOrders.algo.ts:225
	// assert(this.orderbook(orderId).exists)
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop
	assert

	// src/contracts/LimitOrders.algo.ts:226
	// boxSnap = this.orderbook(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//boxSnap

	// src/contracts/LimitOrders.algo.ts:228
	// assert(boxSnap.isBuyingAlgo !== 0)
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	byte 0x00
	b!=
	assert

	// src/contracts/LimitOrders.algo.ts:230
	// verifyPayTxn(algoPayTxn, {
	//             amount: { greaterThan: 0 },
	//             sender: this.txn.sender,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Amount
	int 0
	>
	assert

	// verify sender
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Sender
	txn Sender
	==
	assert

	// verify receiver
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// src/contracts/LimitOrders.algo.ts:236
	// denominator = <uint256>algoPayTxn.amount * <uint256>this.fee.value
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Amount
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	byte 0x666565 // "fee"
	app_global_get
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	b*
	frame_bury 1 // denominator: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:237
	// feeUint256 = denominator / <uint256>SCALE
	frame_dig 1 // denominator: unsafe uint256
	byte 0x00005af3107a4000
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	b/
	frame_bury 2 // feeUint256: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:240
	// fee = <uint64>feeUint256
	frame_dig 2 // feeUint256: unsafe uint256
	dup
	bitlen
	int 64
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 8
	-
	swap
	substring3
	btoi
	frame_bury 3 // fee: uint64

	// src/contracts/LimitOrders.algo.ts:243
	// algoOutAmount = algoPayTxn.amount - fee
	frame_dig -2 // algoPayTxn: PayTxn
	gtxns Amount
	frame_dig 3 // fee: uint64
	-
	frame_bury 4 // algoOutAmount: uint64

	// src/contracts/LimitOrders.algo.ts:245
	// this.transferTo(boxSnap.maker, algoOutAmount)
	frame_dig 4 // algoOutAmount: uint64
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	callsub transferTo

	// src/contracts/LimitOrders.algo.ts:246
	// this.feeAccumulated.value = this.feeAccumulated.value + fee
	byte 0x6665655f616363 // "fee_acc"
	dup
	app_global_get
	frame_dig 3 // fee: uint64
	+
	app_global_put

	// src/contracts/LimitOrders.algo.ts:249
	// algoOutAmountUint256 = <uint256>algoOutAmount
	frame_dig 4 // algoOutAmount: uint64
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	frame_bury 5 // algoOutAmountUint256: uint256

	// src/contracts/LimitOrders.algo.ts:250
	// boxAlgoAmountUint256 = <uint256>(boxSnap.algoAmount)
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 40 8
	btoi
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	frame_bury 6 // boxAlgoAmountUint256: uint256

	// src/contracts/LimitOrders.algo.ts:251
	// arc200OutAmount = ((algoOutAmountUint256 * boxSnap.arc200Amount) / boxAlgoAmountUint256)
	frame_dig 5 // algoOutAmountUint256: uint256
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 48 32
	b*
	frame_dig 6 // boxAlgoAmountUint256: uint256
	b/
	frame_bury 7 // arc200OutAmount: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:253
	// this.arc200TransferTo(boxSnap.arc200Id, this.txn.sender, <uint256>arc200OutAmount)
	frame_dig 7 // arc200OutAmount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	txn Sender
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 32 8
	btoi
	callsub arc200TransferTo

	// src/contracts/LimitOrders.algo.ts:255
	// newArc200Amount = boxSnap.arc200Amount - arc200OutAmount
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 48 32
	frame_dig 7 // arc200OutAmount: unsafe uint256
	b-
	frame_bury 8 // newArc200Amount: unsafe uint256

	// src/contracts/LimitOrders.algo.ts:256
	// newAlgoAmount = boxSnap.algoAmount - algoOutAmount
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 40 8
	btoi
	frame_dig 4 // algoOutAmount: uint64
	-
	frame_bury 9 // newAlgoAmount: uint64

	// src/contracts/LimitOrders.algo.ts:258
	// this.FillOrder.log({
	//             orderId: orderId,
	//             maker: this.orderbook(orderId).value.maker,
	//             taker: this.txn.sender,
	//             filledAlgoAmount: algoOutAmount,
	//             filledArc200Amount: arc200OutAmount,
	//             orderDirection: 1,
	//             fee: <uint256>fee
	//         })
	byte 0x0db8f73c // FillOrder(uint64,address,address,uint64,uint256,uint8,uint256)
	frame_dig -1 // orderId: uint64
	itob
	frame_dig -1 // orderId: uint64
	itob
	box_get
	assert
	extract 0 32
	concat
	txn Sender
	concat
	frame_dig 4 // algoOutAmount: uint64
	itob
	concat
	frame_dig 7 // arc200OutAmount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	byte 0x01
	concat
	frame_dig 3 // fee: uint64
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	concat
	concat
	log

	// if1_condition
	// src/contracts/LimitOrders.algo.ts:268
	// newAlgoAmount <= 1000
	frame_dig 9 // newAlgoAmount: uint64
	int 1000
	<=
	bz if1_else

	// if1_consequent
	// src/contracts/LimitOrders.algo.ts:269
	// this.orderbook(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del
	b if1_end

if1_else:
	// src/contracts/LimitOrders.algo.ts:271
	// this.orderbook(orderId).value = {
	//                 maker: boxSnap.maker,
	//                 arc200Id: boxSnap.arc200Id,
	//                 algoAmount: newAlgoAmount,
	//                 arc200Amount: newArc200Amount,
	//                 isBuyingAlgo: boxSnap.isBuyingAlgo,
	//             }
	frame_dig -1 // orderId: uint64
	itob
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 32 8
	btoi
	itob
	concat
	frame_dig 9 // newAlgoAmount: uint64
	itob
	concat
	frame_dig 8 // newArc200Amount: unsafe uint256
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	int 32
	-
	swap
	substring3
	concat
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	concat
	box_put

if1_end:
	retsub

abi_route_cancelOrder:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancelOrder(uint64)void
	callsub cancelOrder
	int 1
	return

// cancelOrder(uint64)void
cancelOrder:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/contracts/LimitOrders.algo.ts:282
	// assert(this.orderbook(orderId).exists)
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop
	assert

	// src/contracts/LimitOrders.algo.ts:283
	// boxSnap = this.orderbook(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//boxSnap

	// src/contracts/LimitOrders.algo.ts:284
	// assert(boxSnap.maker === this.txn.sender)
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	txn Sender
	==
	assert

	// if2_condition
	// src/contracts/LimitOrders.algo.ts:286
	// boxSnap.isBuyingAlgo === 0
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	byte 0x00
	b==
	bz if2_else

	// if2_consequent
	// src/contracts/LimitOrders.algo.ts:287
	// this.transferTo(boxSnap.maker, boxSnap.algoAmount)
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 40 8
	btoi
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	callsub transferTo

	// src/contracts/LimitOrders.algo.ts:288
	// this.CancelOrder.log({
	//                 maker: boxSnap.maker,
	//                 orderId: orderId,
	//                 returnedAmount: <uint256>boxSnap.algoAmount,
	//                 orderDirection: boxSnap.isBuyingAlgo
	//             })
	byte 0x29d99bd0 // CancelOrder(uint64,address,uint256,uint8)
	frame_dig -1 // orderId: uint64
	itob
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	concat
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 40 8
	btoi
	itob
	dup
	bitlen
	int 256
	<=
	assert
	byte 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	b&
	concat
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	concat
	concat
	log
	b if2_end

if2_else:
	// src/contracts/LimitOrders.algo.ts:295
	// this.arc200TransferTo(boxSnap.arc200Id, boxSnap.maker, boxSnap.arc200Amount)
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 48 32
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 32 8
	btoi
	callsub arc200TransferTo

	// src/contracts/LimitOrders.algo.ts:296
	// this.CancelOrder.log({
	//                 maker: boxSnap.maker,
	//                 orderId: orderId,
	//                 returnedAmount: boxSnap.arc200Amount,
	//                 orderDirection: boxSnap.isBuyingAlgo
	//             })
	byte 0x29d99bd0 // CancelOrder(uint64,address,uint256,uint8)
	frame_dig -1 // orderId: uint64
	itob
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 0 32
	concat
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 48 32
	concat
	frame_dig 0 // storage key//boxSnap
	box_get
	assert
	extract 80 1
	concat
	concat
	log

if2_end:
	// src/contracts/LimitOrders.algo.ts:304
	// this.orderbook(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del
	retsub

abi_route_registerOnline:
	// vote_key_dilution: uint64
	txna ApplicationArgs 6
	btoi

	// vote_last: uint64
	txna ApplicationArgs 5
	btoi

	// vote_first: uint64
	txna ApplicationArgs 4
	btoi

	// vote_pk: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// state_proof_pk: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// selection_pk: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute registerOnline(uint64,uint64,uint64,byte[],byte[],byte[])void
	callsub registerOnline
	int 1
	return

// registerOnline(uint64,uint64,uint64,byte[],byte[],byte[])void
registerOnline:
	proto 6 0

	// src/contracts/LimitOrders.algo.ts:308
	// assert(this.txn.sender === this.owner.value)
	txn Sender
	byte 0x6f776e6572 // "owner"
	app_global_get
	==
	assert

	// src/contracts/LimitOrders.algo.ts:310
	// sendOnlineKeyRegistration({
	//             sender: this.app.address,
	//             selectionPK: selection_pk,
	//             stateProofPK: state_proof_pk,
	//             votePK: vote_pk,
	//             voteFirst: vote_first,
	//             voteLast: vote_last,
	//             voteKeyDilution: vote_key_dilution,
	//             fee: 1000,
	//         })
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// src/contracts/LimitOrders.algo.ts:311
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:312
	// selectionPK: selection_pk
	frame_dig -1 // selection_pk: bytes
	itxn_field SelectionPK

	// src/contracts/LimitOrders.algo.ts:313
	// stateProofPK: state_proof_pk
	frame_dig -2 // state_proof_pk: bytes
	itxn_field StateProofPK

	// src/contracts/LimitOrders.algo.ts:314
	// votePK: vote_pk
	frame_dig -3 // vote_pk: bytes
	itxn_field VotePK

	// src/contracts/LimitOrders.algo.ts:315
	// voteFirst: vote_first
	frame_dig -4 // vote_first: uint64
	itxn_field VoteFirst

	// src/contracts/LimitOrders.algo.ts:316
	// voteLast: vote_last
	frame_dig -5 // vote_last: uint64
	itxn_field VoteLast

	// src/contracts/LimitOrders.algo.ts:317
	// voteKeyDilution: vote_key_dilution
	frame_dig -6 // vote_key_dilution: uint64
	itxn_field VoteKeyDilution

	// src/contracts/LimitOrders.algo.ts:318
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

abi_route_registerOffline:
	// execute registerOffline()void
	callsub registerOffline
	int 1
	return

// registerOffline()void
registerOffline:
	proto 0 0

	// src/contracts/LimitOrders.algo.ts:323
	// assert(this.txn.sender === this.owner.value)
	txn Sender
	byte 0x6f776e6572 // "owner"
	app_global_get
	==
	assert

	// src/contracts/LimitOrders.algo.ts:325
	// sendOfflineKeyRegistration({
	//             sender: this.app.address,
	//             fee: 1000
	//         })
	itxn_begin
	int keyreg
	itxn_field TypeEnum

	// src/contracts/LimitOrders.algo.ts:326
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// src/contracts/LimitOrders.algo.ts:327
	// fee: 1000
	int 1000
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

create_NoOp:
	method "createApplication(address,uint64)void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "setFee(uint64)void"
	method "setOwner(address)void"
	method "collectFee(uint64)void"
	method "createAlgoSellOrder(pay,application,uint256)void"
	method "createAlgoBuyOrder(application,uint256,uint64)void"
	method "fillAlgoToArc200Order(uint64,uint256)void"
	method "fillArc200ToAlgoOrder(uint64,pay)void"
	method "cancelOrder(uint64)void"
	method "registerOnline(byte[],byte[],byte[],uint64,uint64,uint64)void"
	method "registerOffline()void"
	txna ApplicationArgs 0
	match abi_route_setFee abi_route_setOwner abi_route_collectFee abi_route_createAlgoSellOrder abi_route_createAlgoBuyOrder abi_route_fillAlgoToArc200Order abi_route_fillArc200ToAlgoOrder abi_route_cancelOrder abi_route_registerOnline abi_route_registerOffline
	err

call_UpdateApplication:
	method "updateApplication()void"
	txna ApplicationArgs 0
	match abi_route_updateApplication
	err